// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: rbac.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUserRole = `-- name: AddUserRole :exec
INSERT INTO user_roles (user_id, tenant_id, role_id)
VALUES ($1, $2, $3)
ON CONFLICT DO NOTHING
`

type AddUserRoleParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	RoleID   pgtype.UUID `json:"role_id"`
}

func (q *Queries) AddUserRole(ctx context.Context, arg AddUserRoleParams) error {
	_, err := q.db.Exec(ctx, addUserRole, arg.UserID, arg.TenantID, arg.RoleID)
	return err
}

const createRole = `-- name: CreateRole :one
INSERT INTO roles (id, tenant_id, name, description)
VALUES ($1, $2, $3, $4)
RETURNING id, tenant_id, name, description, created_at, updated_at
`

type CreateRoleParams struct {
	ID          pgtype.UUID `json:"id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Role, error) {
	row := q.db.QueryRow(ctx, createRole,
		arg.ID,
		arg.TenantID,
		arg.Name,
		arg.Description,
	)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM roles WHERE id = $1 AND tenant_id = $2
`

type DeleteRoleParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteRole(ctx context.Context, arg DeleteRoleParams) error {
	_, err := q.db.Exec(ctx, deleteRole, arg.ID, arg.TenantID)
	return err
}

const deleteRolePermission = `-- name: DeleteRolePermission :exec
DELETE FROM role_permissions
WHERE role_id = $1 AND permission_id = $2 AND scope_type = $3
  AND (resource_type IS NOT DISTINCT FROM $4)
  AND (resource_id IS NOT DISTINCT FROM $5)
`

type DeleteRolePermissionParams struct {
	RoleID       pgtype.UUID `json:"role_id"`
	PermissionID pgtype.UUID `json:"permission_id"`
	ScopeType    string      `json:"scope_type"`
	ResourceType pgtype.Text `json:"resource_type"`
	ResourceID   pgtype.Text `json:"resource_id"`
}

func (q *Queries) DeleteRolePermission(ctx context.Context, arg DeleteRolePermissionParams) error {
	_, err := q.db.Exec(ctx, deleteRolePermission,
		arg.RoleID,
		arg.PermissionID,
		arg.ScopeType,
		arg.ResourceType,
		arg.ResourceID,
	)
	return err
}

const getPermissionByKey = `-- name: GetPermissionByKey :one
SELECT id, key, description, created_at, updated_at
FROM permissions
WHERE key = $1
`

func (q *Queries) GetPermissionByKey(ctx context.Context, key string) (Permission, error) {
	row := q.db.QueryRow(ctx, getPermissionByKey, key)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRoleByName = `-- name: GetRoleByName :one
SELECT id, tenant_id, name, description, created_at, updated_at
FROM roles
WHERE tenant_id = $1 AND name = $2
`

type GetRoleByNameParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Name     string      `json:"name"`
}

func (q *Queries) GetRoleByName(ctx context.Context, arg GetRoleByNameParams) (Role, error) {
	row := q.db.QueryRow(ctx, getRoleByName, arg.TenantID, arg.Name)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listACLPermissionKeysForGroups = `-- name: ListACLPermissionKeysForGroups :many
SELECT a.subject_id AS group_id, p.key, a.object_type, a.object_id
FROM acl_tuples a
JOIN permissions p ON p.id = a.permission_id
WHERE a.tenant_id = $1 AND a.subject_type = 'group' AND a.subject_id = ANY($2::uuid[])
`

type ListACLPermissionKeysForGroupsParams struct {
	TenantID pgtype.UUID   `json:"tenant_id"`
	Column2  []pgtype.UUID `json:"column_2"`
}

type ListACLPermissionKeysForGroupsRow struct {
	GroupID    pgtype.UUID `json:"group_id"`
	Key        string      `json:"key"`
	ObjectType string      `json:"object_type"`
	ObjectID   pgtype.Text `json:"object_id"`
}

func (q *Queries) ListACLPermissionKeysForGroups(ctx context.Context, arg ListACLPermissionKeysForGroupsParams) ([]ListACLPermissionKeysForGroupsRow, error) {
	rows, err := q.db.Query(ctx, listACLPermissionKeysForGroups, arg.TenantID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListACLPermissionKeysForGroupsRow
	for rows.Next() {
		var i ListACLPermissionKeysForGroupsRow
		if err := rows.Scan(
			&i.GroupID,
			&i.Key,
			&i.ObjectType,
			&i.ObjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listACLPermissionKeysForUser = `-- name: ListACLPermissionKeysForUser :many
SELECT p.key, a.object_type, a.object_id
FROM acl_tuples a
JOIN permissions p ON p.id = a.permission_id
WHERE a.tenant_id = $1 AND a.subject_type = 'user' AND a.subject_id = $2
`

type ListACLPermissionKeysForUserParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	SubjectID pgtype.UUID `json:"subject_id"`
}

type ListACLPermissionKeysForUserRow struct {
	Key        string      `json:"key"`
	ObjectType string      `json:"object_type"`
	ObjectID   pgtype.Text `json:"object_id"`
}

func (q *Queries) ListACLPermissionKeysForUser(ctx context.Context, arg ListACLPermissionKeysForUserParams) ([]ListACLPermissionKeysForUserRow, error) {
	rows, err := q.db.Query(ctx, listACLPermissionKeysForUser, arg.TenantID, arg.SubjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListACLPermissionKeysForUserRow
	for rows.Next() {
		var i ListACLPermissionKeysForUserRow
		if err := rows.Scan(&i.Key, &i.ObjectType, &i.ObjectID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPermissions = `-- name: ListPermissions :many

SELECT id, key, description, created_at, updated_at
FROM permissions
ORDER BY key
`

// RBAC v2 queries: roles, permissions, role_permissions, user_roles, groups, acl tuples
func (q *Queries) ListPermissions(ctx context.Context) ([]Permission, error) {
	rows, err := q.db.Query(ctx, listPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRolePermissionKeys = `-- name: ListRolePermissionKeys :many
SELECT rp.role_id, p.key, rp.scope_type, rp.resource_type, rp.resource_id
FROM role_permissions rp
JOIN permissions p ON p.id = rp.permission_id
WHERE rp.role_id = ANY($1::uuid[])
ORDER BY rp.role_id, p.key
`

type ListRolePermissionKeysRow struct {
	RoleID       pgtype.UUID `json:"role_id"`
	Key          string      `json:"key"`
	ScopeType    string      `json:"scope_type"`
	ResourceType pgtype.Text `json:"resource_type"`
	ResourceID   pgtype.Text `json:"resource_id"`
}

func (q *Queries) ListRolePermissionKeys(ctx context.Context, dollar_1 []pgtype.UUID) ([]ListRolePermissionKeysRow, error) {
	rows, err := q.db.Query(ctx, listRolePermissionKeys, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRolePermissionKeysRow
	for rows.Next() {
		var i ListRolePermissionKeysRow
		if err := rows.Scan(
			&i.RoleID,
			&i.Key,
			&i.ScopeType,
			&i.ResourceType,
			&i.ResourceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRolesByTenant = `-- name: ListRolesByTenant :many
SELECT id, tenant_id, name, description, created_at, updated_at
FROM roles
WHERE tenant_id = $1
ORDER BY name
`

func (q *Queries) ListRolesByTenant(ctx context.Context, tenantID pgtype.UUID) ([]Role, error) {
	rows, err := q.db.Query(ctx, listRolesByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserGroups = `-- name: ListUserGroups :many
SELECT group_id
FROM group_members
WHERE user_id = $1
`

func (q *Queries) ListUserGroups(ctx context.Context, userID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, listUserGroups, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var group_id pgtype.UUID
		if err := rows.Scan(&group_id); err != nil {
			return nil, err
		}
		items = append(items, group_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserRoleIDs = `-- name: ListUserRoleIDs :many
SELECT role_id
FROM user_roles
WHERE user_id = $1 AND tenant_id = $2
`

type ListUserRoleIDsParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) ListUserRoleIDs(ctx context.Context, arg ListUserRoleIDsParams) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, listUserRoleIDs, arg.UserID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var role_id pgtype.UUID
		if err := rows.Scan(&role_id); err != nil {
			return nil, err
		}
		items = append(items, role_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserRole = `-- name: RemoveUserRole :exec
DELETE FROM user_roles WHERE user_id = $1 AND tenant_id = $2 AND role_id = $3
`

type RemoveUserRoleParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	RoleID   pgtype.UUID `json:"role_id"`
}

func (q *Queries) RemoveUserRole(ctx context.Context, arg RemoveUserRoleParams) error {
	_, err := q.db.Exec(ctx, removeUserRole, arg.UserID, arg.TenantID, arg.RoleID)
	return err
}

const updateRole = `-- name: UpdateRole :one
UPDATE roles
SET name = $3, description = $4, updated_at = now()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, name, description, created_at, updated_at
`

type UpdateRoleParams struct {
	ID          pgtype.UUID `json:"id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (Role, error) {
	row := q.db.QueryRow(ctx, updateRole,
		arg.ID,
		arg.TenantID,
		arg.Name,
		arg.Description,
	)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertRolePermission = `-- name: UpsertRolePermission :exec
INSERT INTO role_permissions (role_id, permission_id, scope_type, resource_type, resource_id)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (role_id, permission_id, scope_type, resource_type, resource_id) DO NOTHING
`

type UpsertRolePermissionParams struct {
	RoleID       pgtype.UUID `json:"role_id"`
	PermissionID pgtype.UUID `json:"permission_id"`
	ScopeType    string      `json:"scope_type"`
	ResourceType pgtype.Text `json:"resource_type"`
	ResourceID   pgtype.Text `json:"resource_id"`
}

func (q *Queries) UpsertRolePermission(ctx context.Context, arg UpsertRolePermissionParams) error {
	_, err := q.db.Exec(ctx, upsertRolePermission,
		arg.RoleID,
		arg.PermissionID,
		arg.ScopeType,
		arg.ResourceType,
		arg.ResourceID,
	)
	return err
}
