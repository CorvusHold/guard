// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sso.sql

package db

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSSOAuthAttempt = `-- name: CreateSSOAuthAttempt :one

INSERT INTO sso_auth_attempts (
    tenant_id,
    provider_id,
    user_id,
    state,
    status,
    error_code,
    error_message,
    ip_address,
    user_agent
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, tenant_id, provider_id, user_id, state, status, error_code, error_message, ip_address, user_agent, initiated_at, completed_at
`

type CreateSSOAuthAttemptParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	ProviderID   pgtype.UUID `json:"provider_id"`
	UserID       pgtype.UUID `json:"user_id"`
	State        pgtype.Text `json:"state"`
	Status       string      `json:"status"`
	ErrorCode    pgtype.Text `json:"error_code"`
	ErrorMessage pgtype.Text `json:"error_message"`
	IpAddress    *netip.Addr `json:"ip_address"`
	UserAgent    pgtype.Text `json:"user_agent"`
}

// SSO Authentication Attempts
func (q *Queries) CreateSSOAuthAttempt(ctx context.Context, arg CreateSSOAuthAttemptParams) (SsoAuthAttempt, error) {
	row := q.db.QueryRow(ctx, createSSOAuthAttempt,
		arg.TenantID,
		arg.ProviderID,
		arg.UserID,
		arg.State,
		arg.Status,
		arg.ErrorCode,
		arg.ErrorMessage,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i SsoAuthAttempt
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProviderID,
		&i.UserID,
		&i.State,
		&i.Status,
		&i.ErrorCode,
		&i.ErrorMessage,
		&i.IpAddress,
		&i.UserAgent,
		&i.InitiatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const createSSOProvider = `-- name: CreateSSOProvider :one

INSERT INTO sso_providers (
    tenant_id,
    name,
    slug,
    provider_type,
    -- OIDC fields
    issuer,
    authorization_endpoint,
    token_endpoint,
    userinfo_endpoint,
    jwks_uri,
    client_id,
    client_secret,
    scopes,
    response_type,
    response_mode,
    -- SAML fields
    entity_id,
    acs_url,
    slo_url,
    idp_metadata_url,
    idp_metadata_xml,
    idp_entity_id,
    idp_sso_url,
    idp_slo_url,
    idp_certificate,
    sp_certificate,
    sp_private_key,
    sp_certificate_expires_at,
    want_assertions_signed,
    want_response_signed,
    sign_requests,
    force_authn,
    allow_idp_initiated,
    linking_policy,
    -- Common fields
    attribute_mapping,
    enabled,
    allow_signup,
    trust_email_verified,
    domains,
    created_by,
    updated_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14,
    $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26,
    $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39
) RETURNING id, tenant_id, name, slug, provider_type, issuer, authorization_endpoint, token_endpoint, userinfo_endpoint, jwks_uri, client_id, client_secret, scopes, response_type, response_mode, entity_id, acs_url, slo_url, idp_metadata_url, idp_metadata_xml, idp_entity_id, idp_sso_url, idp_slo_url, idp_certificate, sp_certificate, sp_private_key, sp_certificate_expires_at, want_assertions_signed, want_response_signed, sign_requests, force_authn, attribute_mapping, enabled, allow_signup, trust_email_verified, domains, created_at, updated_at, created_by, updated_by, allow_idp_initiated, linking_policy
`

type CreateSSOProviderParams struct {
	TenantID               pgtype.UUID        `json:"tenant_id"`
	Name                   string             `json:"name"`
	Slug                   string             `json:"slug"`
	ProviderType           string             `json:"provider_type"`
	Issuer                 pgtype.Text        `json:"issuer"`
	AuthorizationEndpoint  pgtype.Text        `json:"authorization_endpoint"`
	TokenEndpoint          pgtype.Text        `json:"token_endpoint"`
	UserinfoEndpoint       pgtype.Text        `json:"userinfo_endpoint"`
	JwksUri                pgtype.Text        `json:"jwks_uri"`
	ClientID               pgtype.Text        `json:"client_id"`
	ClientSecret           pgtype.Text        `json:"client_secret"`
	Scopes                 []string           `json:"scopes"`
	ResponseType           pgtype.Text        `json:"response_type"`
	ResponseMode           pgtype.Text        `json:"response_mode"`
	EntityID               pgtype.Text        `json:"entity_id"`
	AcsUrl                 pgtype.Text        `json:"acs_url"`
	SloUrl                 pgtype.Text        `json:"slo_url"`
	IdpMetadataUrl         pgtype.Text        `json:"idp_metadata_url"`
	IdpMetadataXml         pgtype.Text        `json:"idp_metadata_xml"`
	IdpEntityID            pgtype.Text        `json:"idp_entity_id"`
	IdpSsoUrl              pgtype.Text        `json:"idp_sso_url"`
	IdpSloUrl              pgtype.Text        `json:"idp_slo_url"`
	IdpCertificate         pgtype.Text        `json:"idp_certificate"`
	SpCertificate          pgtype.Text        `json:"sp_certificate"`
	SpPrivateKey           pgtype.Text        `json:"sp_private_key"`
	SpCertificateExpiresAt pgtype.Timestamptz `json:"sp_certificate_expires_at"`
	WantAssertionsSigned   pgtype.Bool        `json:"want_assertions_signed"`
	WantResponseSigned     pgtype.Bool        `json:"want_response_signed"`
	SignRequests           pgtype.Bool        `json:"sign_requests"`
	ForceAuthn             pgtype.Bool        `json:"force_authn"`
	AllowIdpInitiated      pgtype.Bool        `json:"allow_idp_initiated"`
	LinkingPolicy          pgtype.Text        `json:"linking_policy"`
	AttributeMapping       []byte             `json:"attribute_mapping"`
	Enabled                pgtype.Bool        `json:"enabled"`
	AllowSignup            pgtype.Bool        `json:"allow_signup"`
	TrustEmailVerified     pgtype.Bool        `json:"trust_email_verified"`
	Domains                []string           `json:"domains"`
	CreatedBy              pgtype.UUID        `json:"created_by"`
	UpdatedBy              pgtype.UUID        `json:"updated_by"`
}

// SSO Provider Management
func (q *Queries) CreateSSOProvider(ctx context.Context, arg CreateSSOProviderParams) (SsoProvider, error) {
	row := q.db.QueryRow(ctx, createSSOProvider,
		arg.TenantID,
		arg.Name,
		arg.Slug,
		arg.ProviderType,
		arg.Issuer,
		arg.AuthorizationEndpoint,
		arg.TokenEndpoint,
		arg.UserinfoEndpoint,
		arg.JwksUri,
		arg.ClientID,
		arg.ClientSecret,
		arg.Scopes,
		arg.ResponseType,
		arg.ResponseMode,
		arg.EntityID,
		arg.AcsUrl,
		arg.SloUrl,
		arg.IdpMetadataUrl,
		arg.IdpMetadataXml,
		arg.IdpEntityID,
		arg.IdpSsoUrl,
		arg.IdpSloUrl,
		arg.IdpCertificate,
		arg.SpCertificate,
		arg.SpPrivateKey,
		arg.SpCertificateExpiresAt,
		arg.WantAssertionsSigned,
		arg.WantResponseSigned,
		arg.SignRequests,
		arg.ForceAuthn,
		arg.AllowIdpInitiated,
		arg.LinkingPolicy,
		arg.AttributeMapping,
		arg.Enabled,
		arg.AllowSignup,
		arg.TrustEmailVerified,
		arg.Domains,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i SsoProvider
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Slug,
		&i.ProviderType,
		&i.Issuer,
		&i.AuthorizationEndpoint,
		&i.TokenEndpoint,
		&i.UserinfoEndpoint,
		&i.JwksUri,
		&i.ClientID,
		&i.ClientSecret,
		&i.Scopes,
		&i.ResponseType,
		&i.ResponseMode,
		&i.EntityID,
		&i.AcsUrl,
		&i.SloUrl,
		&i.IdpMetadataUrl,
		&i.IdpMetadataXml,
		&i.IdpEntityID,
		&i.IdpSsoUrl,
		&i.IdpSloUrl,
		&i.IdpCertificate,
		&i.SpCertificate,
		&i.SpPrivateKey,
		&i.SpCertificateExpiresAt,
		&i.WantAssertionsSigned,
		&i.WantResponseSigned,
		&i.SignRequests,
		&i.ForceAuthn,
		&i.AttributeMapping,
		&i.Enabled,
		&i.AllowSignup,
		&i.TrustEmailVerified,
		&i.Domains,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.AllowIdpInitiated,
		&i.LinkingPolicy,
	)
	return i, err
}

const createSSOSession = `-- name: CreateSSOSession :one

INSERT INTO sso_sessions (
    tenant_id,
    provider_id,
    user_id,
    session_index,
    name_id,
    id_token_hint,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, tenant_id, provider_id, user_id, session_index, name_id, id_token_hint, created_at, expires_at, terminated_at
`

type CreateSSOSessionParams struct {
	TenantID     pgtype.UUID        `json:"tenant_id"`
	ProviderID   pgtype.UUID        `json:"provider_id"`
	UserID       pgtype.UUID        `json:"user_id"`
	SessionIndex pgtype.Text        `json:"session_index"`
	NameID       pgtype.Text        `json:"name_id"`
	IDTokenHint  pgtype.Text        `json:"id_token_hint"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
}

// SSO Sessions
func (q *Queries) CreateSSOSession(ctx context.Context, arg CreateSSOSessionParams) (SsoSession, error) {
	row := q.db.QueryRow(ctx, createSSOSession,
		arg.TenantID,
		arg.ProviderID,
		arg.UserID,
		arg.SessionIndex,
		arg.NameID,
		arg.IDTokenHint,
		arg.ExpiresAt,
	)
	var i SsoSession
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProviderID,
		&i.UserID,
		&i.SessionIndex,
		&i.NameID,
		&i.IDTokenHint,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.TerminatedAt,
	)
	return i, err
}

const deleteSSOProvider = `-- name: DeleteSSOProvider :exec
DELETE FROM sso_providers
WHERE id = $1 AND tenant_id = $2
`

type DeleteSSOProviderParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteSSOProvider(ctx context.Context, arg DeleteSSOProviderParams) error {
	_, err := q.db.Exec(ctx, deleteSSOProvider, arg.ID, arg.TenantID)
	return err
}

const findSSOProviderByDomain = `-- name: FindSSOProviderByDomain :one
SELECT id, tenant_id, name, slug, provider_type, issuer, authorization_endpoint, token_endpoint, userinfo_endpoint, jwks_uri, client_id, client_secret, scopes, response_type, response_mode, entity_id, acs_url, slo_url, idp_metadata_url, idp_metadata_xml, idp_entity_id, idp_sso_url, idp_slo_url, idp_certificate, sp_certificate, sp_private_key, sp_certificate_expires_at, want_assertions_signed, want_response_signed, sign_requests, force_authn, attribute_mapping, enabled, allow_signup, trust_email_verified, domains, created_at, updated_at, created_by, updated_by, allow_idp_initiated, linking_policy FROM sso_providers
WHERE tenant_id = $1
  AND enabled = TRUE
  AND $2::text = ANY(domains)
ORDER BY created_at DESC
LIMIT 1
`

type FindSSOProviderByDomainParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Domain   string      `json:"domain"`
}

func (q *Queries) FindSSOProviderByDomain(ctx context.Context, arg FindSSOProviderByDomainParams) (SsoProvider, error) {
	row := q.db.QueryRow(ctx, findSSOProviderByDomain, arg.TenantID, arg.Domain)
	var i SsoProvider
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Slug,
		&i.ProviderType,
		&i.Issuer,
		&i.AuthorizationEndpoint,
		&i.TokenEndpoint,
		&i.UserinfoEndpoint,
		&i.JwksUri,
		&i.ClientID,
		&i.ClientSecret,
		&i.Scopes,
		&i.ResponseType,
		&i.ResponseMode,
		&i.EntityID,
		&i.AcsUrl,
		&i.SloUrl,
		&i.IdpMetadataUrl,
		&i.IdpMetadataXml,
		&i.IdpEntityID,
		&i.IdpSsoUrl,
		&i.IdpSloUrl,
		&i.IdpCertificate,
		&i.SpCertificate,
		&i.SpPrivateKey,
		&i.SpCertificateExpiresAt,
		&i.WantAssertionsSigned,
		&i.WantResponseSigned,
		&i.SignRequests,
		&i.ForceAuthn,
		&i.AttributeMapping,
		&i.Enabled,
		&i.AllowSignup,
		&i.TrustEmailVerified,
		&i.Domains,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.AllowIdpInitiated,
		&i.LinkingPolicy,
	)
	return i, err
}

const getActiveSSOSessions = `-- name: GetActiveSSOSessions :many
SELECT id, tenant_id, provider_id, user_id, session_index, name_id, id_token_hint, created_at, expires_at, terminated_at FROM sso_sessions
WHERE user_id = $1
  AND terminated_at IS NULL
  AND (expires_at IS NULL OR expires_at > NOW())
ORDER BY created_at DESC
`

func (q *Queries) GetActiveSSOSessions(ctx context.Context, userID pgtype.UUID) ([]SsoSession, error) {
	rows, err := q.db.Query(ctx, getActiveSSOSessions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SsoSession
	for rows.Next() {
		var i SsoSession
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProviderID,
			&i.UserID,
			&i.SessionIndex,
			&i.NameID,
			&i.IDTokenHint,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.TerminatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSSOAuthAttemptByState = `-- name: GetSSOAuthAttemptByState :one
SELECT id, tenant_id, provider_id, user_id, state, status, error_code, error_message, ip_address, user_agent, initiated_at, completed_at FROM sso_auth_attempts
WHERE state = $1 AND status = 'initiated'
ORDER BY initiated_at DESC
LIMIT 1
`

func (q *Queries) GetSSOAuthAttemptByState(ctx context.Context, state pgtype.Text) (SsoAuthAttempt, error) {
	row := q.db.QueryRow(ctx, getSSOAuthAttemptByState, state)
	var i SsoAuthAttempt
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProviderID,
		&i.UserID,
		&i.State,
		&i.Status,
		&i.ErrorCode,
		&i.ErrorMessage,
		&i.IpAddress,
		&i.UserAgent,
		&i.InitiatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getSSOProvider = `-- name: GetSSOProvider :one
SELECT id, tenant_id, name, slug, provider_type, issuer, authorization_endpoint, token_endpoint, userinfo_endpoint, jwks_uri, client_id, client_secret, scopes, response_type, response_mode, entity_id, acs_url, slo_url, idp_metadata_url, idp_metadata_xml, idp_entity_id, idp_sso_url, idp_slo_url, idp_certificate, sp_certificate, sp_private_key, sp_certificate_expires_at, want_assertions_signed, want_response_signed, sign_requests, force_authn, attribute_mapping, enabled, allow_signup, trust_email_verified, domains, created_at, updated_at, created_by, updated_by, allow_idp_initiated, linking_policy FROM sso_providers
WHERE id = $1 AND tenant_id = $2
`

type GetSSOProviderParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetSSOProvider(ctx context.Context, arg GetSSOProviderParams) (SsoProvider, error) {
	row := q.db.QueryRow(ctx, getSSOProvider, arg.ID, arg.TenantID)
	var i SsoProvider
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Slug,
		&i.ProviderType,
		&i.Issuer,
		&i.AuthorizationEndpoint,
		&i.TokenEndpoint,
		&i.UserinfoEndpoint,
		&i.JwksUri,
		&i.ClientID,
		&i.ClientSecret,
		&i.Scopes,
		&i.ResponseType,
		&i.ResponseMode,
		&i.EntityID,
		&i.AcsUrl,
		&i.SloUrl,
		&i.IdpMetadataUrl,
		&i.IdpMetadataXml,
		&i.IdpEntityID,
		&i.IdpSsoUrl,
		&i.IdpSloUrl,
		&i.IdpCertificate,
		&i.SpCertificate,
		&i.SpPrivateKey,
		&i.SpCertificateExpiresAt,
		&i.WantAssertionsSigned,
		&i.WantResponseSigned,
		&i.SignRequests,
		&i.ForceAuthn,
		&i.AttributeMapping,
		&i.Enabled,
		&i.AllowSignup,
		&i.TrustEmailVerified,
		&i.Domains,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.AllowIdpInitiated,
		&i.LinkingPolicy,
	)
	return i, err
}

const getSSOProviderBySlug = `-- name: GetSSOProviderBySlug :one
SELECT id, tenant_id, name, slug, provider_type, issuer, authorization_endpoint, token_endpoint, userinfo_endpoint, jwks_uri, client_id, client_secret, scopes, response_type, response_mode, entity_id, acs_url, slo_url, idp_metadata_url, idp_metadata_xml, idp_entity_id, idp_sso_url, idp_slo_url, idp_certificate, sp_certificate, sp_private_key, sp_certificate_expires_at, want_assertions_signed, want_response_signed, sign_requests, force_authn, attribute_mapping, enabled, allow_signup, trust_email_verified, domains, created_at, updated_at, created_by, updated_by, allow_idp_initiated, linking_policy FROM sso_providers
WHERE tenant_id = $1 AND slug = $2
`

type GetSSOProviderBySlugParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Slug     string      `json:"slug"`
}

func (q *Queries) GetSSOProviderBySlug(ctx context.Context, arg GetSSOProviderBySlugParams) (SsoProvider, error) {
	row := q.db.QueryRow(ctx, getSSOProviderBySlug, arg.TenantID, arg.Slug)
	var i SsoProvider
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Slug,
		&i.ProviderType,
		&i.Issuer,
		&i.AuthorizationEndpoint,
		&i.TokenEndpoint,
		&i.UserinfoEndpoint,
		&i.JwksUri,
		&i.ClientID,
		&i.ClientSecret,
		&i.Scopes,
		&i.ResponseType,
		&i.ResponseMode,
		&i.EntityID,
		&i.AcsUrl,
		&i.SloUrl,
		&i.IdpMetadataUrl,
		&i.IdpMetadataXml,
		&i.IdpEntityID,
		&i.IdpSsoUrl,
		&i.IdpSloUrl,
		&i.IdpCertificate,
		&i.SpCertificate,
		&i.SpPrivateKey,
		&i.SpCertificateExpiresAt,
		&i.WantAssertionsSigned,
		&i.WantResponseSigned,
		&i.SignRequests,
		&i.ForceAuthn,
		&i.AttributeMapping,
		&i.Enabled,
		&i.AllowSignup,
		&i.TrustEmailVerified,
		&i.Domains,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.AllowIdpInitiated,
		&i.LinkingPolicy,
	)
	return i, err
}

const getSSOSessionByIndex = `-- name: GetSSOSessionByIndex :one
SELECT id, tenant_id, provider_id, user_id, session_index, name_id, id_token_hint, created_at, expires_at, terminated_at FROM sso_sessions
WHERE provider_id = $1
  AND session_index = $2
  AND terminated_at IS NULL
LIMIT 1
`

type GetSSOSessionByIndexParams struct {
	ProviderID   pgtype.UUID `json:"provider_id"`
	SessionIndex pgtype.Text `json:"session_index"`
}

func (q *Queries) GetSSOSessionByIndex(ctx context.Context, arg GetSSOSessionByIndexParams) (SsoSession, error) {
	row := q.db.QueryRow(ctx, getSSOSessionByIndex, arg.ProviderID, arg.SessionIndex)
	var i SsoSession
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProviderID,
		&i.UserID,
		&i.SessionIndex,
		&i.NameID,
		&i.IDTokenHint,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.TerminatedAt,
	)
	return i, err
}

const listEnabledSSOProviders = `-- name: ListEnabledSSOProviders :many
SELECT id, tenant_id, name, slug, provider_type, domains, enabled
FROM sso_providers
WHERE tenant_id = $1 AND enabled = TRUE
ORDER BY name ASC
`

type ListEnabledSSOProvidersRow struct {
	ID           pgtype.UUID `json:"id"`
	TenantID     pgtype.UUID `json:"tenant_id"`
	Name         string      `json:"name"`
	Slug         string      `json:"slug"`
	ProviderType string      `json:"provider_type"`
	Domains      []string    `json:"domains"`
	Enabled      pgtype.Bool `json:"enabled"`
}

func (q *Queries) ListEnabledSSOProviders(ctx context.Context, tenantID pgtype.UUID) ([]ListEnabledSSOProvidersRow, error) {
	rows, err := q.db.Query(ctx, listEnabledSSOProviders, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEnabledSSOProvidersRow
	for rows.Next() {
		var i ListEnabledSSOProvidersRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Slug,
			&i.ProviderType,
			&i.Domains,
			&i.Enabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSSOAuthAttemptsByProvider = `-- name: ListSSOAuthAttemptsByProvider :many
SELECT id, tenant_id, provider_id, user_id, state, status, error_code, error_message, ip_address, user_agent, initiated_at, completed_at FROM sso_auth_attempts
WHERE provider_id = $1
ORDER BY initiated_at DESC
LIMIT $2 OFFSET $3
`

type ListSSOAuthAttemptsByProviderParams struct {
	ProviderID pgtype.UUID `json:"provider_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) ListSSOAuthAttemptsByProvider(ctx context.Context, arg ListSSOAuthAttemptsByProviderParams) ([]SsoAuthAttempt, error) {
	rows, err := q.db.Query(ctx, listSSOAuthAttemptsByProvider, arg.ProviderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SsoAuthAttempt
	for rows.Next() {
		var i SsoAuthAttempt
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProviderID,
			&i.UserID,
			&i.State,
			&i.Status,
			&i.ErrorCode,
			&i.ErrorMessage,
			&i.IpAddress,
			&i.UserAgent,
			&i.InitiatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSSOAuthAttemptsByTenant = `-- name: ListSSOAuthAttemptsByTenant :many
SELECT id, tenant_id, provider_id, user_id, state, status, error_code, error_message, ip_address, user_agent, initiated_at, completed_at FROM sso_auth_attempts
WHERE tenant_id = $1
ORDER BY initiated_at DESC
LIMIT $2 OFFSET $3
`

type ListSSOAuthAttemptsByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListSSOAuthAttemptsByTenant(ctx context.Context, arg ListSSOAuthAttemptsByTenantParams) ([]SsoAuthAttempt, error) {
	rows, err := q.db.Query(ctx, listSSOAuthAttemptsByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SsoAuthAttempt
	for rows.Next() {
		var i SsoAuthAttempt
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProviderID,
			&i.UserID,
			&i.State,
			&i.Status,
			&i.ErrorCode,
			&i.ErrorMessage,
			&i.IpAddress,
			&i.UserAgent,
			&i.InitiatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSSOProviders = `-- name: ListSSOProviders :many
SELECT id, tenant_id, name, slug, provider_type, issuer, authorization_endpoint, token_endpoint, userinfo_endpoint, jwks_uri, client_id, client_secret, scopes, response_type, response_mode, entity_id, acs_url, slo_url, idp_metadata_url, idp_metadata_xml, idp_entity_id, idp_sso_url, idp_slo_url, idp_certificate, sp_certificate, sp_private_key, sp_certificate_expires_at, want_assertions_signed, want_response_signed, sign_requests, force_authn, attribute_mapping, enabled, allow_signup, trust_email_verified, domains, created_at, updated_at, created_by, updated_by, allow_idp_initiated, linking_policy FROM sso_providers
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListSSOProvidersParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListSSOProviders(ctx context.Context, arg ListSSOProvidersParams) ([]SsoProvider, error) {
	rows, err := q.db.Query(ctx, listSSOProviders, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SsoProvider
	for rows.Next() {
		var i SsoProvider
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Slug,
			&i.ProviderType,
			&i.Issuer,
			&i.AuthorizationEndpoint,
			&i.TokenEndpoint,
			&i.UserinfoEndpoint,
			&i.JwksUri,
			&i.ClientID,
			&i.ClientSecret,
			&i.Scopes,
			&i.ResponseType,
			&i.ResponseMode,
			&i.EntityID,
			&i.AcsUrl,
			&i.SloUrl,
			&i.IdpMetadataUrl,
			&i.IdpMetadataXml,
			&i.IdpEntityID,
			&i.IdpSsoUrl,
			&i.IdpSloUrl,
			&i.IdpCertificate,
			&i.SpCertificate,
			&i.SpPrivateKey,
			&i.SpCertificateExpiresAt,
			&i.WantAssertionsSigned,
			&i.WantResponseSigned,
			&i.SignRequests,
			&i.ForceAuthn,
			&i.AttributeMapping,
			&i.Enabled,
			&i.AllowSignup,
			&i.TrustEmailVerified,
			&i.Domains,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.AllowIdpInitiated,
			&i.LinkingPolicy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const terminateAllUserSSOSessions = `-- name: TerminateAllUserSSOSessions :exec
UPDATE sso_sessions
SET terminated_at = NOW()
WHERE user_id = $1
  AND terminated_at IS NULL
`

func (q *Queries) TerminateAllUserSSOSessions(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, terminateAllUserSSOSessions, userID)
	return err
}

const terminateSSOSession = `-- name: TerminateSSOSession :exec
UPDATE sso_sessions
SET terminated_at = NOW()
WHERE id = $1
`

func (q *Queries) TerminateSSOSession(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, terminateSSOSession, id)
	return err
}

const updateSSOAuthAttempt = `-- name: UpdateSSOAuthAttempt :exec
UPDATE sso_auth_attempts
SET
    status = $1,
    error_code = $2,
    error_message = $3,
    user_id = $4,
    completed_at = NOW()
WHERE id = $5
`

type UpdateSSOAuthAttemptParams struct {
	Status       string      `json:"status"`
	ErrorCode    pgtype.Text `json:"error_code"`
	ErrorMessage pgtype.Text `json:"error_message"`
	UserID       pgtype.UUID `json:"user_id"`
	ID           pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateSSOAuthAttempt(ctx context.Context, arg UpdateSSOAuthAttemptParams) error {
	_, err := q.db.Exec(ctx, updateSSOAuthAttempt,
		arg.Status,
		arg.ErrorCode,
		arg.ErrorMessage,
		arg.UserID,
		arg.ID,
	)
	return err
}

const updateSSOProvider = `-- name: UpdateSSOProvider :exec
UPDATE sso_providers
SET
    name = COALESCE($1, name),
    enabled = COALESCE($2, enabled),
    -- OIDC fields
    issuer = COALESCE($3, issuer),
    authorization_endpoint = COALESCE($4, authorization_endpoint),
    token_endpoint = COALESCE($5, token_endpoint),
    userinfo_endpoint = COALESCE($6, userinfo_endpoint),
    jwks_uri = COALESCE($7, jwks_uri),
    client_id = COALESCE($8, client_id),
    client_secret = COALESCE($9, client_secret),
    scopes = COALESCE($10, scopes),
    response_type = COALESCE($11, response_type),
    response_mode = COALESCE($12, response_mode),
    -- SAML fields
    entity_id = COALESCE($13, entity_id),
    acs_url = COALESCE($14, acs_url),
    slo_url = COALESCE($15, slo_url),
    idp_metadata_url = COALESCE($16, idp_metadata_url),
    idp_metadata_xml = COALESCE($17, idp_metadata_xml),
    idp_entity_id = COALESCE($18, idp_entity_id),
    idp_sso_url = COALESCE($19, idp_sso_url),
    idp_slo_url = COALESCE($20, idp_slo_url),
    idp_certificate = COALESCE($21, idp_certificate),
    sp_certificate = COALESCE($22, sp_certificate),
    sp_private_key = COALESCE($23, sp_private_key),
    sp_certificate_expires_at = COALESCE($24, sp_certificate_expires_at),
    want_assertions_signed = COALESCE($25, want_assertions_signed),
    want_response_signed = COALESCE($26, want_response_signed),
    sign_requests = COALESCE($27, sign_requests),
    force_authn = COALESCE($28, force_authn),
    allow_idp_initiated = COALESCE($29, allow_idp_initiated),
    linking_policy = COALESCE($30, linking_policy),
    -- Common fields
    attribute_mapping = COALESCE($31, attribute_mapping),
    allow_signup = COALESCE($32, allow_signup),
    trust_email_verified = COALESCE($33, trust_email_verified),
    domains = COALESCE($34, domains),
    updated_by = $35,
    updated_at = NOW()
WHERE id = $36 AND tenant_id = $37
`

type UpdateSSOProviderParams struct {
	Name                   pgtype.Text        `json:"name"`
	Enabled                pgtype.Bool        `json:"enabled"`
	Issuer                 pgtype.Text        `json:"issuer"`
	AuthorizationEndpoint  pgtype.Text        `json:"authorization_endpoint"`
	TokenEndpoint          pgtype.Text        `json:"token_endpoint"`
	UserinfoEndpoint       pgtype.Text        `json:"userinfo_endpoint"`
	JwksUri                pgtype.Text        `json:"jwks_uri"`
	ClientID               pgtype.Text        `json:"client_id"`
	ClientSecret           pgtype.Text        `json:"client_secret"`
	Scopes                 []string           `json:"scopes"`
	ResponseType           pgtype.Text        `json:"response_type"`
	ResponseMode           pgtype.Text        `json:"response_mode"`
	EntityID               pgtype.Text        `json:"entity_id"`
	AcsUrl                 pgtype.Text        `json:"acs_url"`
	SloUrl                 pgtype.Text        `json:"slo_url"`
	IdpMetadataUrl         pgtype.Text        `json:"idp_metadata_url"`
	IdpMetadataXml         pgtype.Text        `json:"idp_metadata_xml"`
	IdpEntityID            pgtype.Text        `json:"idp_entity_id"`
	IdpSsoUrl              pgtype.Text        `json:"idp_sso_url"`
	IdpSloUrl              pgtype.Text        `json:"idp_slo_url"`
	IdpCertificate         pgtype.Text        `json:"idp_certificate"`
	SpCertificate          pgtype.Text        `json:"sp_certificate"`
	SpPrivateKey           pgtype.Text        `json:"sp_private_key"`
	SpCertificateExpiresAt pgtype.Timestamptz `json:"sp_certificate_expires_at"`
	WantAssertionsSigned   pgtype.Bool        `json:"want_assertions_signed"`
	WantResponseSigned     pgtype.Bool        `json:"want_response_signed"`
	SignRequests           pgtype.Bool        `json:"sign_requests"`
	ForceAuthn             pgtype.Bool        `json:"force_authn"`
	AllowIdpInitiated      pgtype.Bool        `json:"allow_idp_initiated"`
	LinkingPolicy          pgtype.Text        `json:"linking_policy"`
	AttributeMapping       []byte             `json:"attribute_mapping"`
	AllowSignup            pgtype.Bool        `json:"allow_signup"`
	TrustEmailVerified     pgtype.Bool        `json:"trust_email_verified"`
	Domains                []string           `json:"domains"`
	UpdatedBy              pgtype.UUID        `json:"updated_by"`
	ID                     pgtype.UUID        `json:"id"`
	TenantID               pgtype.UUID        `json:"tenant_id"`
}

func (q *Queries) UpdateSSOProvider(ctx context.Context, arg UpdateSSOProviderParams) error {
	_, err := q.db.Exec(ctx, updateSSOProvider,
		arg.Name,
		arg.Enabled,
		arg.Issuer,
		arg.AuthorizationEndpoint,
		arg.TokenEndpoint,
		arg.UserinfoEndpoint,
		arg.JwksUri,
		arg.ClientID,
		arg.ClientSecret,
		arg.Scopes,
		arg.ResponseType,
		arg.ResponseMode,
		arg.EntityID,
		arg.AcsUrl,
		arg.SloUrl,
		arg.IdpMetadataUrl,
		arg.IdpMetadataXml,
		arg.IdpEntityID,
		arg.IdpSsoUrl,
		arg.IdpSloUrl,
		arg.IdpCertificate,
		arg.SpCertificate,
		arg.SpPrivateKey,
		arg.SpCertificateExpiresAt,
		arg.WantAssertionsSigned,
		arg.WantResponseSigned,
		arg.SignRequests,
		arg.ForceAuthn,
		arg.AllowIdpInitiated,
		arg.LinkingPolicy,
		arg.AttributeMapping,
		arg.AllowSignup,
		arg.TrustEmailVerified,
		arg.Domains,
		arg.UpdatedBy,
		arg.ID,
		arg.TenantID,
	)
	return err
}
